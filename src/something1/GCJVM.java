package something1;

public class GCJVM {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//JVM-------------------------------------------------------------------------------------------------------------------
		/*程序计数器

　　			程序计数器（Program Counter Register）是JVM中一块较小的内存区域，保存着当前线程执行的虚拟机字节码指令的内存地址。
			Java多线程的实现，其实是通过线程间的轮流切换并分配处理器执行时间的方式来实现的，在任何时刻，处理器都只会执行一个线程中的指令。
			在多线程场景下，为了保证线程切换回来后，还能恢复到原先状态，找到原先执行的指令，所以每个线程都会设立一个程序计数器，并且各个线程之间不会互相影响，程序计数器为"线程私有"的内存区域。

　　			如果当前线程正在执行Java方法，则程序计数器保存的是虚拟机字节码的内存地址，如果正在执行的是Native方法（非Java方法，JVM底层有许多非Java编写的函数实现），
			计数器则为空。程序计数器是唯一一个在Java规范中没有规定任何OutOfMemory场景的区域。
		 * 
		 *虚拟机栈

		　　虚拟机栈（Java Virtual Machine Stacks）和线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈，
			所以Java栈也是"线程私有"的内存区域，这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，
			栈帧是用来存储方法数据和部分过程结果的数据结构，每一个方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程。
		
		　　虚拟机栈是一个后入先出的数据结构，线程运行过程中，只有一个栈帧是处于活跃状态的，被称为"当前活动帧栈"，当前活动帧栈始终是虚拟机栈的栈顶元素。
		 * 
		 *本地方法栈

　　			本地方法栈（Native Method Stack）和虚拟机栈的作用相似，不过虚拟机栈是为Java方法服务的，而本地方法栈是为Native方法服务的。 
		 * 
		 * 方法区

		　　方法区（Method Area）是用于存储类结构信息的地方，包括常量池、静态变量、构造函数等类型信息，类型信息是由类加载器在类加载时从类文件中提取出来的。		
		　　方法区同样存在垃圾收集，因为用户通过自定义加载器加载的一些类同样会成为垃圾，JVM会回收一个未被引用类所占的空间，以使方法区的空间达到最小。		
		　　方法区中还存在着常量池，常量池包含着一些常量和符号引用（加载类的连接阶段中的解析过程会将符号引用转换为直接引用）。		
		　　方法区是线程共享的。
		 * 
		 * 堆

　　			堆		（heap）是存储java实例或者对象的地方，是GC的主要区域，同样是线程共享的内存区域。
		 * 
		 * 总结

		　　 1、所有线程共享的内存数据区：方法区，堆。而虚拟机栈，本地方法栈和程序计数器都是线程私有的。
		
		　　 2、存放于栈中的东西如下：
		 　　　  2.1 每个线程包含一个栈区,栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。对象都存放在堆区中。
		
		　　　　2.2 每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。
		 　　　  2.3 方法的形式参数，方法调用完后从栈空间回收
		 　　　  2.4 引用对象的地址，引用完后，栈空间地址立即被回收，堆空间等待GC
		
		　　 3、存放于堆中的东西如下：
		
		　　　　3.1 存储的全部是对象，每个对象包含一个与之对应的class信息
		
		　　　　3.2 Jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身
		
		　　 4、存放于方法区中的东西如下：
		
		　　　　4.1 存放线程所执行的字节码指令
		
		　　　　4.2 跟堆一样.被所有线程共享.方法区包含：所有的class和static变量
		
		　　　　4.3 常量池位于方法区中，
		 * */
		
		/*
		 * 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )
		 * 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )
		 */
		
//GC-----------------------------------------------------------------------------------------------------------------------		
		/*GCRoots根节点如何选择？
		 * java通过可达性分析来判断对象是否存活。
			基本思想是通过一系列称为“GC roots”的对象作为起始点，可以作为根节点的是：
			  虚拟机栈（栈帧中的本地变量表）中引用的对象
			  本地方法栈中JNI（即一般说的Native方法）引用的对象
			  方法区中类静态属性引用的对象
			  方法区中常量引用的对象
			作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量）中。
			虚拟机、本地方法栈这都是局部变量，某个方法执行完，某些局部使用的对象可以被回收。
		 * 
		 * */
		
		
		/*
		 *  1、引用计数法：给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。

			2、可达性分析法:对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。			
				1. 如果对象在进行可达性分析后发现没有与GCRoots相连的引用链，则该对象被第一次标记并进行一次筛选，
					筛选条件为是否有必要执行该对象的finalize方法，若对象没有覆盖finalize方法或者该finalize方法
					已经被虚拟机执行过了（ 
						finalize()在什么时候被调用? 有三种情况      
						1.所有对象被Garbage Collection时自动调用,比如运行System.gc()的时候.      
						2.程序退出时为每个对象调用一次finalize方法。      
						3.显式的调用finalize方法），
					则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，
					那么，这个对象会被放置在一个叫F-Queue的队列中，之后会由虚拟机自动建立的、优先级低的Finalizer线程去执行，
					而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。
				2.对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GCRoots引用链，
					如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，
					如果对象还是没有拯救自己，那就会被回收。它只能拯救自己一次，第二次就被回收了。
					此外，从我们可以得知，一个堆对象的this引用会永远存在，在方法体内可以将this引用赋值给其他变量，这样堆中对象就可以被其他变量所引用，即不会被回收.
		 * 
		 * 
		 * */
		
	}

}
